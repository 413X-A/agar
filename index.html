<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Agar.io Mobile Clone</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
      background-color: #222;
      touch-action: none;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font: bold 18px Arial;
      z-index: 10;
    }
    #joystick, #splitBtn {
      position: absolute;
      bottom: 20px;
      background: rgba(255,255,255,0.1);
      border: 2px solid #888;
      border-radius: 50%;
      touch-action: none;
    }
    #joystick {
      width: 120px;
      height: 120px;
      left: 20px;
    }
    #splitBtn {
      width: 80px;
      height: 80px;
      right: 20px;
    }
  </style>
</head>
<body>
  <div id="score">Score: 10</div>
  <canvas id="gameCanvas"></canvas>
  <div id="joystick"></div>
  <div id="splitBtn">Split</div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const world = {
      width: 4000,
      height: 4000
    };

    const playerParts = [{
      x: world.width / 2,
      y: world.height / 2,
      radius: 20,
      vx: 0,
      vy: 0,
      mergeTimeout: 0
    }];

    let score = 20;

    const bots = [];
    const food = [];

    function randomColor() {
      return `hsl(${Math.random() * 360}, 70%, 50%)`;
    }

    function createFood(n) {
      for (let i = 0; i < n; i++) {
        food.push({
          x: Math.random() * world.width,
          y: Math.random() * world.height,
          radius: 4,
          color: "yellow"
        });
      }
    }

    function createBots(n) {
      for (let i = 0; i < n; i++) {
        bots.push({
          x: Math.random() * world.width,
          y: Math.random() * world.height,
          radius: 20 + Math.random() * 40, // Größere Bots
          color: randomColor(),
          target: null,
          speed: 1.2
        });
      }
    }

    // Joystick input
    let joystick = { x: 0, y: 0 };
    let mouseX = 0, mouseY = 0;
    let useJoystick = false;

    const joystickElem = document.getElementById("joystick");
    joystickElem.addEventListener("touchmove", e => {
      useJoystick = true;
      const rect = joystickElem.getBoundingClientRect();
      const touch = e.touches[0];
      joystick.x = ((touch.clientX - rect.left) - 60) / 60;
      joystick.y = ((touch.clientY - rect.top) - 60) / 60;
    });

    joystickElem.addEventListener("touchend", () => {
      joystick.x = 0;
      joystick.y = 0;
    });

    // Maus (Desktop)
    window.addEventListener("mousemove", e => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // Split button
    document.getElementById("splitBtn").addEventListener("click", () => {
      if (playerParts.length < 4) {
        const main = playerParts[0];
        if (main.radius > 15) {
          const angle = getInputAngle();
          const splitPart = {
            x: main.x + Math.cos(angle) * main.radius,
            y: main.y + Math.sin(angle) * main.radius,
            radius: main.radius / 2,
            vx: Math.cos(angle) * 10,
            vy: Math.sin(angle) * 10,
            mergeTimeout: 300
          };
          main.radius /= 2;
          playerParts.push(splitPart);
        }
      }
    });

    function getInputAngle() {
      if (useJoystick) return Math.atan2(joystick.y, joystick.x);
      return Math.atan2(mouseY - canvas.height / 2, mouseX - canvas.width / 2);
    }

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function updateCamera() {
      const center = playerParts[0];
      return {
        x: center.x - canvas.width / 2,
        y: center.y - canvas.height / 2
      };
    }

    function drawCircle(obj, cam, label = "") {
      ctx.beginPath();
      ctx.arc(obj.x - cam.x, obj.y - cam.y, obj.radius, 0, Math.PI * 2);
      ctx.fillStyle = obj.color || "lime";
      ctx.fill();

      if (label) {
        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(label, obj.x - cam.x, obj.y - cam.y + 4);
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = updateCamera();

      // Spielerbewegung
      playerParts.forEach(part => {
        let angle = getInputAngle();
        const speed = Math.max(0.6, 3 * (20 / part.radius));
        if (part.mergeTimeout > 0) {
          part.mergeTimeout--;
        } else if (playerParts.length > 1) {
          // Merge, wenn nah
          const main = playerParts[0];
          if (part !== main && distance(part, main) < main.radius + part.radius) {
            main.radius += part.radius;
            playerParts.splice(playerParts.indexOf(part), 1);
          }
        }

        // Bewegung
        if (part.vx !== 0 || part.vy !== 0) {
          part.x += part.vx;
          part.y += part.vy;
          part.vx *= 0.9;
          part.vy *= 0.9;
        } else {
          if (useJoystick || (!useJoystick && mouseX && mouseY)) {
            part.x += Math.cos(angle) * speed;
            part.y += Math.sin(angle) * speed;
          }
        }

        // Begrenzung
        part.x = Math.max(part.radius, Math.min(world.width - part.radius, part.x));
        part.y = Math.max(part.radius, Math.min(world.height - part.radius, part.y));
      });

      // Food sammeln
      playerParts.forEach(part => {
        for (let i = food.length - 1; i >= 0; i--) {
          if (distance(part, food[i]) < part.radius) {
            food.splice(i, 1);
            part.radius += 0.2;
            score++;
            document.getElementById("score").innerText = "Score: " + score;
          }
        }
      });

      // Bots KI
      bots.forEach(bot => {
        let flee = false;
        playerParts.forEach(part => {
          if (distance(bot, part) < 200 && bot.radius < part.radius) {
            const angle = Math.atan2(bot.y - part.y, bot.x - part.x);
            bot.x += Math.cos(angle) * bot.speed;
            bot.y += Math.sin(angle) * bot.speed;
            flee = true;
          }
        });

        if (!flee) {
          if (!bot.target || distance(bot, bot.target) < 5) {
            bot.target = food[Math.floor(Math.random() * food.length)];
          }
          if (bot.target) {
            const angle = Math.atan2(bot.target.y - bot.y, bot.target.x - bot.x);
            bot.x += Math.cos(angle) * bot.speed;
            bot.y += Math.sin(angle) * bot.speed;
          }
        }

        // Essen
        for (let i = food.length - 1; i >= 0; i--) {
          if (distance(bot, food[i]) < bot.radius) {
            food.splice(i, 1);
            bot.radius += 0.2;
          }
        }

        // Kollision mit Spieler
        playerParts.forEach(part => {
          if (distance(part, bot) < part.radius + bot.radius) {
            if (part.radius > bot.radius + 2) {
              part.radius += bot.radius * 0.2;
              bots.splice(bots.indexOf(bot), 1);
            } else if (bot.radius > part.radius + 2) {
              alert("Game Over! Dein Score: " + score);
              location.reload();
            }
          }
        });

        drawCircle(bot, cam);
      });

      // Food zeichnen
      food.forEach(f => drawCircle(f, cam));

      // Spieler zeichnen + Label
      playerParts.forEach(part => {
        drawCircle(part, cam, Math.floor(part.radius));
      });

      if (food.length < 200) createFood(3);
      requestAnimationFrame(animate);
    }

    // Init
    createFood(300);
    createBots(20);
    animate();
  </script>
</body>
</html>
