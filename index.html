<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Agar.io Clone - Bots automatisch generieren</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    font-family: Arial, sans-serif;
    background: #f0f0f0;
  }
  canvas {
    display: block;
    background: #e9e9e9;
  }
  #splitBtn {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    font-size: 20px;
    z-index: 10;
    cursor: pointer;
  }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 18px;
    background: rgba(255,255,255,0.7);
    padding: 6px 12px;
    border-radius: 5px;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<button id="splitBtn">Split</button>
<div id="info">Score: 0</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const worldSize = 9000; // 3x so groß
const foods = [];
const bots = [];
const botRemains = [];

const colors = ["red", "orange", "purple", "green", "blue", "pink", "cyan", "magenta", "brown", "darkblue"];

let player = {
  x: worldSize / 2,
  y: worldSize / 2,
  radius: 20,
  score: 100,
  vx: 0,
  vy: 0,
  isMain: true,
  boostFrames: 0,
  color: "blue"
};
let playerPieces = [player];

const mouse = { x: canvas.width / 2, y: canvas.height / 2 };

const WIN_SCORE = 100000;

// Spawn initial food and bots
for (let i = 0; i < 7500; i++) spawnFood();
for (let i = 0; i < 20; i++) spawnBot();

function spawnFood() {
  foods.push({
    x: Math.random() * worldSize,
    y: Math.random() * worldSize,
    radius: 3,
    color: "green"
  });
}

function spawnBot() {
  const score = 30 + Math.random() * 70;
  bots.push({
    x: Math.random() * worldSize,
    y: Math.random() * worldSize,
    radius: Math.sqrt(score) + 10,
    score,
    vx: 0,
    vy: 0,
    boostFrames: 0,
    splitCooldown: 0,
    color: colors[Math.floor(Math.random() * colors.length)]
  });
}

function getDistance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function splitPlayer() {
  // Split nur wenn groß genug
  playerPieces.forEach((p, index) => {
    if (p.score > 40) {
      const splitScore = p.score / 2;
      p.score = splitScore;
      p.radius = Math.sqrt(splitScore) + 10;

      const splitAngle = Math.random() * Math.PI * 2;
      const newPiece = {
        x: p.x + Math.cos(splitAngle) * 30,
        y: p.y + Math.sin(splitAngle) * 30,
        radius: Math.sqrt(splitScore) + 10,
        score: splitScore,
        vx: Math.cos(splitAngle) * 15,
        vy: Math.sin(splitAngle) * 15,
        boostFrames: 40,
        color: p.color,
        isMain: false
      };
      playerPieces.push(newPiece);
    }
  });
}

function update() {
  // Update player movement for each piece
  playerPieces.forEach(p => {
    const angle = Math.atan2(mouse.y - canvas.height / 2, mouse.x - canvas.width / 2);
    let speed = Math.max(2, 10 - p.radius / 20);
    if (p.boostFrames > 0) {
      speed += 10;
      p.boostFrames--;
    }
    p.vx = Math.cos(angle) * speed;
    p.vy = Math.sin(angle) * speed;
    p.x += p.vx;
    p.y += p.vy;
    p.x = Math.max(p.radius, Math.min(worldSize - p.radius, p.x));
    p.y = Math.max(p.radius, Math.min(worldSize - p.radius, p.y));
  });

  // Bots AI & movement
  for (let i = 0; i < bots.length; i++) {
    let bot = bots[i];
    if (bot.splitCooldown > 0) bot.splitCooldown--;
    let target = null;

    // Priorität: nahe Remains sammeln wenn bot größer
    let nearbyRemains = botRemains.filter(r => getDistance(bot, r) < 300 && bot.score > r.score * 1.1);
    if (nearbyRemains.length > 0) {
      target = nearbyRemains.reduce((a,b) => getDistance(bot, a) < getDistance(bot,b) ? a : b);
    } else {
      // Sonst Nahrung oder kleinere Gegner
      const potentialTargets = [...foods, ...playerPieces, ...bots.filter(b => b !== bot)];
      let edibleTargets = potentialTargets.filter(t => bot.score > t.score * 1.25);
      if (edibleTargets.length > 0) {
        target = edibleTargets.reduce((a,b) => getDistance(bot, a) < getDistance(bot,b) ? a : b);
      } else {
        // Sonst nächstes Food als Ziel
        target = foods.reduce((a,b) => getDistance(bot, a) < getDistance(bot,b) ? a : b);
      }
    }

    if (bot.boostFrames > 0) {
      bot.x += bot.vx * 1.8;
      bot.y += bot.vy * 1.8;
      bot.boostFrames--;
    } else {
      if(target){
        const moveAngle = Math.atan2(target.y - bot.y, target.x - bot.x);
        const moveSpeed = Math.max(1, 8 - bot.radius / 20);
        bot.vx = Math.cos(moveAngle) * moveSpeed;
        bot.vy = Math.sin(moveAngle) * moveSpeed;
        bot.x += bot.vx;
        bot.y += bot.vy;
      }
    }

    bot.x = Math.max(bot.radius, Math.min(worldSize - bot.radius, bot.x));
    bot.y = Math.max(bot.radius, Math.min(worldSize - bot.radius, bot.y));

    // Bot frisst Food
    for (let j = foods.length - 1; j >= 0; j--) {
      if (getDistance(bot, foods[j]) < bot.radius) {
        bot.score++;
        bot.radius = Math.sqrt(bot.score) + 10;
        foods.splice(j, 1);
      }
    }

    // Bot frisst player pieces
    for (let j = playerPieces.length - 1; j >= 0; j--) {
      let p = playerPieces[j];
      if (p && getDistance(bot, p) < bot.radius * 0.75 && bot.score > p.score * 1.25) {
        bot.score += p.score;
        bot.radius = Math.sqrt(bot.score) + 10;
        if (p === player) {
          alert("Game Over - Bot gewinnt!");
          window.location.reload();
          return;
        }
        playerPieces.splice(j, 1);
      }
    }

    // Bot frisst bot remains (tote Teile)
    for(let j = botRemains.length -1; j >= 0; j--){
      let r = botRemains[j];
      if(getDistance(bot, r) < bot.radius && bot.score > r.score * 1.1){
        bot.score += r.score;
        bot.radius = Math.sqrt(bot.score) + 10;
        botRemains.splice(j,1);
      }
    }

    // Bot frisst andere Bots - kein Spawn mehr
    for (let j = bots.length - 1; j >= 0; j--) {
      if (i !== j && bots[i] && bots[j]) {
        if (getDistance(bots[i], bots[j]) < bots[i].radius * 0.75 &&
            bots[i].score > bots[j].score * 1.25) {
          bots[i].score += bots[j].score;
          bots[i].radius = Math.sqrt(bots[i].score) + 10;
          bots.splice(j, 1);
          if (j < i) i--;
        }
      }
    }

    // Bot split: Nur wenn sinnvoll
if (bot.score > 40 && bot.splitCooldown === 0) {
  // Liste von potentiellen Zielen: Spielerteile und andere Bots (außer sich selbst)
  const preyList = [...playerPieces, ...bots.filter(b => b !== bot)].filter(p =>
    bot.score > p.score * 1.25 && getDistance(bot, p) < 250
  );

  if (preyList.length > 0) {
    bot.splitCooldown = 60;
    bot.boostFrames = 40;

    bot.score /= 2;
    bot.radius = Math.sqrt(bot.score) + 10;

    const angle = Math.random() * 2 * Math.PI;

    bots.push({
      x: bot.x + Math.cos(angle) * 40,
      y: bot.y + Math.sin(angle) * 40,
      radius: Math.sqrt(bot.score) + 10,
      score: bot.score,
      vx: Math.cos(angle) * 10,
      vy: Math.sin(angle) * 10,
      boostFrames: 40,
      splitCooldown: 60,
      color: bot.color
    });
  }
}

// Player frisst Food
for (let i = foods.length - 1; i >= 0; i--) {
playerPieces.forEach((p, idx) => {
if (getDistance(p, foods[i]) < p.radius) {
p.score++;
p.radius = Math.sqrt(p.score) + 10;
foods.splice(i, 1);
}
});
}

// Player frisst bots und botRemains (kann z.B. auf split botteile)
for (let i = bots.length - 1; i >= 0; i--) {
playerPieces.forEach((p, idx) => {
if (getDistance(p, bots[i]) < p.radius * 0.75 && p.score > bots[i].score * 1.25) {
p.score += bots[i].score;
p.radius = Math.sqrt(p.score) + 10;
botRemains.push({
x: bots[i].x,
y: bots[i].y,
score: bots[i].score,
radius: Math.sqrt(bots[i].score) + 10,
color: bots[i].color,
life: 300
});
bots.splice(i, 1);
}
});
}
// Player frisst bot remains
for(let i = botRemains.length - 1; i >= 0; i--){
playerPieces.forEach(p => {
if(getDistance(p, botRemains[i]) < p.radius){
p.score += botRemains[i].score;
p.radius = Math.sqrt(p.score) + 10;
botRemains.splice(i, 1);
}
});
}

// Update bot remains life
for(let i = botRemains.length -1; i>=0; i--){
botRemains[i].life--;
if(botRemains[i].life <= 0){
botRemains.splice(i,1);
}
}

// Respawn food if needed
while (foods.length < 7500) spawnFood();

// Respawn bots if needed (max 20)
while (bots.length < 20) spawnBot();

// Update score for player main piece
player.score = playerPieces.reduce((a,b) => a + b.score, 0);
player.radius = Math.sqrt(player.score) + 10;

if(player.score > WIN_SCORE){
alert("You Win! Congratulations!");
window.location.reload();
}
}

function draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

// Translate to center on average player position
const avgX = playerPieces.reduce((a,b) => a + b.x, 0) / playerPieces.length;
const avgY = playerPieces.reduce((a,b) => a + b.y, 0) / playerPieces.length;
ctx.save();
ctx.translate(canvas.width/2 - avgX, canvas.height/2 - avgY);

// Draw foods
foods.forEach(f => {
ctx.beginPath();
ctx.fillStyle = f.color;
ctx.shadowColor = "black";
ctx.shadowBlur = 3;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;
ctx.arc(f.x, f.y, f.radius, 0, 2*Math.PI);
ctx.fill();
});

// Draw bot remains
botRemains.forEach(r => {
ctx.beginPath();
ctx.fillStyle = r.color;
ctx.globalAlpha = 0.6;
ctx.arc(r.x, r.y, r.radius, 0, 2*Math.PI);
ctx.fill();
ctx.globalAlpha = 1;
});

// Draw bots
bots.forEach(b => {
ctx.beginPath();
ctx.fillStyle = b.color;
ctx.shadowColor = "black";
ctx.shadowBlur = 10;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;
ctx.arc(b.x, b.y, b.radius, 0, 2*Math.PI);
ctx.fill();
ctx.shadowBlur = 0;
});

// Draw player pieces
playerPieces.forEach(p => {
ctx.beginPath();
ctx.fillStyle = p.color;
ctx.shadowColor = "black";
ctx.shadowBlur = 15;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;
ctx.arc(p.x, p.y, p.radius, 0, 2*Math.PI);
ctx.fill();
ctx.shadowBlur = 0;
});

ctx.restore();

// Draw score
document.getElementById("info").textContent = Score: ${Math.floor(player.score)};
}

function gameLoop() {
update();
draw();
requestAnimationFrame(gameLoop);
}

canvas.addEventListener("mousemove", e => {
mouse.x = e.clientX;
mouse.y = e.clientY;
});

window.addEventListener("resize", () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});

document.getElementById("splitBtn").addEventListener("click", () => {
splitPlayer();
});

window.addEventListener("keydown", e => {
  if (e.code === "Space") {
    splitPlayer();
  }
});

gameLoop();
</script>
</body> </html>
