<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agar.io Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        const WORLD_SIZE = 9000;
        const FOOD_COUNT = 2500;
        let food = [];
        let bots = [];
        let playerCells = [{ x: WORLD_SIZE / 2, y: WORLD_SIZE / 2, radius: 20, score: 50, isPlayer: true }];

        function createFood(count) {
            for (let i = 0; i < count; i++) {
                food.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 3,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`
                });
            }
        }

        function createBots(count) {
            for (let i = 0; i < count; i++) {
                bots.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 10 + Math.random() * 40,
                    score: 10 + Math.random() * 100
                });
            }
        }

        createFood(FOOD_COUNT);
        createBots(20);

        let camera = { x: 0, y: 0 };
        let keys = {};
        let mouse = { x: width / 2, y: height / 2 };

        document.addEventListener("mousemove", (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        document.addEventListener("keydown", (e) => {
            keys[e.key] = true;
            if (e.code === "Space") {
                splitPlayer();
            }
        });

        document.addEventListener("keyup", (e) => {
            keys[e.key] = false;
        });

        function splitPlayer() {
            let newCells = [];
            playerCells.forEach(cell => {
                if (cell.score > 20) {
                    let angle = Math.atan2(mouse.y - height / 2, mouse.x - width / 2);
                    let speed = 20;
                    let newScore = cell.score / 2;
                    let newRadius = Math.sqrt(newScore);
                    cell.score = newScore;
                    cell.radius = newRadius;
                    newCells.push({
                        x: cell.x + Math.cos(angle) * 30,
                        y: cell.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: newRadius,
                        score: newScore,
                        isPlayer: true
                    });
                }
            });
            playerCells.push(...newCells);
        }

        function update() {
            for (let cell of playerCells) {
                let angle = Math.atan2(mouse.y - height / 2, mouse.x - width / 2);
                let speed = Math.max(1, 10 - cell.radius / 10);
                cell.x += Math.cos(angle) * speed;
                cell.y += Math.sin(angle) * speed;

                // Clamp to world borders
                cell.x = Math.max(cell.radius, Math.min(WORLD_SIZE - cell.radius, cell.x));
                cell.y = Math.max(cell.radius, Math.min(WORLD_SIZE - cell.radius, cell.y));
            }

            // Move split parts (impulse)
            for (let cell of playerCells) {
                if (cell.vx || cell.vy) {
                    cell.x += cell.vx;
                    cell.y += cell.vy;
                    cell.vx *= 0.95;
                    cell.vy *= 0.95;
                    if (Math.abs(cell.vx) < 0.1) cell.vx = 0;
                    if (Math.abs(cell.vy) < 0.1) cell.vy = 0;
                }
            }

            // Collision with food
            for (let i = food.length - 1; i >= 0; i--) {
                for (let cell of playerCells) {
                    let dx = food[i].x - cell.x;
                    let dy = food[i].y - cell.y;
                    if (Math.hypot(dx, dy) < cell.radius) {
                        cell.score += 1;
                        cell.radius = Math.sqrt(cell.score);
                        food.splice(i, 1);
                        break;
                    }
                }
            }

            // Respawn food
            if (food.length < FOOD_COUNT) {
                createFood(FOOD_COUNT - food.length);
            }

            // Bots avoid larger players
            bots.forEach(bot => {
                let nearest = playerCells.reduce((a, b) => {
                    let da = Math.hypot(bot.x - a.x, bot.y - a.y);
                    let db = Math.hypot(bot.x - b.x, bot.y - b.y);
                    return da < db ? a : b;
                });
                let dx = bot.x - nearest.x;
                let dy = bot.y - nearest.y;
                let dist = Math.hypot(dx, dy);
                if (nearest.radius > bot.radius * 1.15) {
                    bot.x += dx / dist * 2;
                    bot.y += dy / dist * 2;
                } else {
                    bot.x += (Math.random() - 0.5) * 2;
                    bot.y += (Math.random() - 0.5) * 2;
                }

                bot.x = Math.max(bot.radius, Math.min(WORLD_SIZE - bot.radius, bot.x));
                bot.y = Math.max(bot.radius, Math.min(WORLD_SIZE - bot.radius, bot.y));
            });

            // Eating logic
            [...playerCells, ...bots].forEach((cellA, indexA, all) => {
                all.forEach((cellB, indexB) => {
                    if (indexA === indexB || cellA.radius < cellB.radius * 1.15) return;
                    let dx = cellA.x - cellB.x;
                    let dy = cellA.y - cellB.y;
                    if (Math.hypot(dx, dy) < cellA.radius * 0.75) {
                        if (cellB.isPlayer) {
                            playerCells = playerCells.filter(c => c !== cellB);
                        } else {
                            bots = bots.filter(c => c !== cellB);
                        }
                        if (cellA.isPlayer || cellB.isPlayer) {
                            cellA.score += cellB.score;
                            cellA.radius = Math.sqrt(cellA.score);
                        }
                    }
                });
            });

            // Merge split cells
            for (let i = 0; i < playerCells.length; i++) {
                for (let j = i + 1; j < playerCells.length; j++) {
                    let a = playerCells[i];
                    let b = playerCells[j];
                    if (Math.hypot(a.x - b.x, a.y - b.y) < (a.radius + b.radius) / 2 && a.score >= b.score * 1.15) {
                        a.score += b.score;
                        a.radius = Math.sqrt(a.score);
                        playerCells.splice(j, 1);
                        j--;
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            camera.x = playerCells[0].x - width / 2;
            camera.y = playerCells[0].y - height / 2;

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Borders
            ctx.strokeStyle = "black";
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);

            food.forEach(f => {
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                ctx.fill();
            });

            bots.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fillStyle = "red";
                ctx.fill();
            });

            playerCells.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = "blue";
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.font = `${p.radius}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(Math.floor(p.score), p.x, p.y);
            });

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
