<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Agar.io Clone - Intelligente Bots, Split & Leaderboard</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    font-family: Arial, sans-serif;
    background: #f0f0f0;
  }
  canvas {
    display: block;
    background: #e9e9e9;
  }
  #splitBtn {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    font-size: 20px;
    z-index: 10;
  }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 18px;
    background: rgba(255,255,255,0.7);
    padding: 6px 12px;
    border-radius: 5px;
    z-index: 10;
  }
  #leaderboard {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 16px;
    width: 180px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 10;
  }
  #leaderboard h3 {
    margin: 0 0 8px 0;
    font-weight: bold;
    text-align: center;
  }
  #leaderboard ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  #leaderboard li {
    margin-bottom: 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<button id="splitBtn">Split</button>
<div id="info">Score: 0</div>
<div id="leaderboard">
  <h3>Leaderboard Top 10</h3>
  <ul id="leaderboardList"></ul>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const worldSize = 9000; // 3x so groß
const foods = [];
const bots = [];
const botRemains = [];

const colors = ["red", "orange", "purple", "green", "blue", "pink", "cyan", "magenta", "brown", "darkblue"];

let player = {
  x: worldSize / 2,
  y: worldSize / 2,
  radius: 20,
  score: 100,
  vx: 0,
  vy: 0,
  isMain: true,
  boostFrames: 0,
  color: "blue"
};
let playerPieces = [player];

const mouse = { x: canvas.width / 2, y: canvas.height / 2 };

const WIN_SCORE = 100000;

// Spawn initial food and bots
for (let i = 0; i < 7500; i++) spawnFood();
for (let i = 0; i < 20; i++) spawnBot();

function spawnFood() {
  foods.push({
    x: Math.random() * worldSize,
    y: Math.random() * worldSize,
    radius: 3,
    color: "green"
  });
}

function spawnBot() {
  const score = 30 + Math.random() * 70;
  bots.push({
    x: Math.random() * worldSize,
    y: Math.random() * worldSize,
    radius: Math.sqrt(score) + 10,
    score,
    vx: 0,
    vy: 0,
    boostFrames: 0,
    splitCooldown: 0,
    color: colors[Math.floor(Math.random() * colors.length)]
  });
}

function getDistance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function update() {
  // Update player movement
  const angle = Math.atan2(mouse.y - canvas.height / 2, mouse.x - canvas.width / 2);
  let speed = Math.max(2, 10 - player.radius / 20);
  if (player.boostFrames > 0) {
    speed += 10;
    player.boostFrames--;
  }

  player.vx = Math.cos(angle) * speed;
  player.vy = Math.sin(angle) * speed;
  player.x += player.vx;
  player.y += player.vy;

  player.x = Math.max(player.radius, Math.min(worldSize - player.radius, player.x));
  player.y = Math.max(player.radius, Math.min(worldSize - player.radius, player.y));

  // Bots AI & movement
  for (let i = 0; i < bots.length; i++) {
    let bot = bots[i];
    if (bot.splitCooldown > 0) bot.splitCooldown--;

    // Intelligente Zielwahl
    let target = null;

    // 1) Suche nahe Remains die sich lohnen
    let nearbyRemains = botRemains.filter(r => getDistance(bot, r) < 400 && bot.score > r.score * 1.1);
    if (nearbyRemains.length > 0) {
      target = nearbyRemains.reduce((a,b) => getDistance(bot, a) < getDistance(bot,b) ? a : b);
    } else {
      // 2) Suche kleinere Gegner (Spieler + Bots)
      const potentialTargets = [...playerPieces, ...bots.filter(b => b !== bot)];
      let edibleTargets = potentialTargets.filter(t => bot.score > t.score * 1.25);
      if (edibleTargets.length > 0) {
        target = edibleTargets.reduce((a,b) => getDistance(bot, a) < getDistance(bot,b) ? a : b);
      } else {
        // 3) Sonst Nahrung suchen
        if(foods.length > 0){
          target = foods.reduce((a,b) => getDistance(bot, a) < getDistance(bot,b) ? a : b);
        }
      }
    }

    if (bot.boostFrames > 0) {
      bot.x += bot.vx * 1.8;
      bot.y += bot.vy * 1.8;
      bot.boostFrames--;
    } else {
      if(target){
        const moveAngle = Math.atan2(target.y - bot.y, target.x - bot.x);
        const moveSpeed = Math.max(1, 8 - bot.radius / 20);
        bot.vx = Math.cos(moveAngle) * moveSpeed;
        bot.vy = Math.sin(moveAngle) * moveSpeed;
        bot.x += bot.vx;
        bot.y += bot.vy;
      }
    }

    bot.x = Math.max(bot.radius, Math.min(worldSize - bot.radius, bot.x));
    bot.y = Math.max(bot.radius, Math.min(worldSize - bot.radius, bot.y));

    // Bot frisst Food
    for (let j = foods.length - 1; j >= 0; j--) {
      if (getDistance(bot, foods[j]) < bot.radius) {
        bot.score++;
        bot.radius = Math.sqrt(bot.score) + 10;
        foods.splice(j, 1);
      }
    }

    // Bot frisst player pieces
    for (let j = playerPieces.length - 1; j >= 0; j--) {
      let p = playerPieces[j];
      if (p && getDistance(bot, p) < bot.radius * 0.75 && bot.score > p.score * 1.25) {
        bot.score += p.score;
        bot.radius = Math.sqrt(bot.score) + 10;
        if (p === player) {
          alert("Game Over - Bot gewinnt!");
          window.location.reload();
          return;
        }
        playerPieces.splice(j, 1);
      }
    }

    // Bot frisst bot remains (tote Teile)
    for(let j = botRemains.length -1; j >= 0; j--){
      let r = botRemains[j];
      if(getDistance(bot, r) < bot.radius && bot.score > r.score * 1.1){
        bot.score += r.score;
        bot.radius = Math.sqrt(bot.score) + 10;
        botRemains.splice(j,1);
      }
    }

    // Bot frisst andere Bots (kein Spawn mehr)
    for (let j = bots.length - 1; j >= 0; j--) {
      if (i !== j && bots[i] && bots[j]) {
        if (getDistance(bots[i], bots[j]) < bots[i].radius * 0.75 &&
            bots[i].score > bots[j].score * 1.25) {
          bots[i].score += bots[j].score;
          bots[i].radius = Math.sqrt(bots[i].score) + 10;
          bots.splice(j, 1);
          if (j < i) i--;
        }
      }
    }

    // Bot split: Nur wenn sinnvoll
    if (bot.score > 40 && bot.splitCooldown === 0) {
      const preyList = [...playerPieces, ...bots.filter(b => b !== bot)].filter(p =>
        bot.score > p.score * 1.8 && getDistance(bot, p) < 300
      );
      if (preyList.length > 0) {
        const target = preyList[0];
        const splitAngle = Math.atan2(target.y - bot.y, target.x - bot.x);
        const halfScore = bot.score / 2;

        // 1 bewegliches Teil mit Boost, 1 Teil tot und halbtransparent
        bots.push({
          x: bot.x + Math.cos(splitAngle) * 10,
          y: bot.y + Math.sin(splitAngle) * 10,
          score: halfScore,
          radius: Math.sqrt(halfScore) + 10,
          vx: Math.cos(splitAngle) * 10,
          vy: Math.sin(splitAngle) * 10,
          boostFrames: 120,  // langer boost
          splitCooldown: 150,
          color: bot.color
        });

        botRemains.push({
          x: bot.x,
          y: bot.y,
          score: halfScore,
          radius: Math.sqrt(halfScore) + 10,
          color: bot.color
        });

        bot.score = halfScore;
        bot.radius = Math.sqrt(halfScore) + 10;
        bot.splitCooldown = 150;
      }
    }

    // Check bot win condition
    if(bot.score >= WIN_SCORE){
      alert("Ein Bot hat gewonnen!");
      window.location.reload();
      return;
    }
  }

  // Player frisst Food
  for (let i = foods.length - 1; i >= 0; i--) {
    if (getDistance(player, foods[i]) < player.radius) {
      player.score++;
      player.radius = Math.sqrt(player.score) + 10;
      foods.splice(i, 1);
    }
  }

  // Player frisst Bots (kein Spawn mehr)
  for (let i = bots.length - 1; i >= 0; i--) {
    if (getDistance(player, bots[i]) < player.radius * 0.75 && player.score > bots[i].score * 1.25) {
      player.score += bots[i].score;
      player.radius
ChatGPT:
= Math.sqrt(player.score) + 10;
bots.splice(i, 1);
}
}

// Player frisst bot remains
for(let i = botRemains.length -1; i >= 0; i--){
let r = botRemains[i];
if(getDistance(player, r) < player.radius){
player.score += r.score;
player.radius = Math.sqrt(player.score) + 10;
botRemains.splice(i,1);
}
}

// Player pieces update movement + boost decay
for(let i = 1; i < playerPieces.length; i++){
let part = playerPieces[i];
if(part.boostFrames > 0){
part.x += part.vx * 1.8;
part.y += part.vy * 1.8;
part.boostFrames--;
} else {
// Langsame Verlangsamung
part.vx *= 0.9;
part.vy *= 0.9;
part.x += part.vx;
part.y += part.vy;
}

// Kollision mit Food
for(let j = foods.length -1; j >=0; j--){
  if(getDistance(part, foods[j]) < part.radius){
    part.score++;
    part.radius = Math.sqrt(part.score) + 10;
    foods.splice(j,1);
  }
}

// Kollision mit Bots
for(let j = bots.length -1; j >= 0; j--){
  if(getDistance(part, bots[j]) < part.radius * 0.75 && part.score > bots[j].score * 1.25){
    part.score += bots[j].score;
    part.radius = Math.sqrt(part.score) + 10;
    bots.splice(j,1);
  }
}

// Kollision mit bot remains
for(let j = botRemains.length -1; j >= 0; j--){
  if(getDistance(part, botRemains[j]) < part.radius){
    part.score += botRemains[j].score;
    part.radius = Math.sqrt(part.score) + 10;
    botRemains.splice(j,1);
  }
}
}

// Remove player parts if too small
for(let i = playerPieces.length - 1; i > 0; i--){
if(playerPieces[i].score < 5){
playerPieces.splice(i,1);
}
}

// Check player win condition
if(player.score >= WIN_SCORE){
alert("Du hast gewonnen!");
window.location.reload();
return;
}

// Spawn food occasionally if too low
if(foods.length < 6000){
spawnFood();
}
}

function draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

// Kamera Offset (zentriert auf Spieler)
const offsetX = player.x - canvas.width / 2;
const offsetY = player.y - canvas.height / 2;

// Foods zeichnen
foods.forEach(f => {
ctx.beginPath();
ctx.fillStyle = f.color;
ctx.arc(f.x - offsetX, f.y - offsetY, f.radius, 0, Math.PI * 2);
ctx.fill();
});

// Bot remains (halbdurchsichtig)
botRemains.forEach(r => {
ctx.beginPath();
ctx.fillStyle = r.color;
ctx.globalAlpha = 0.3;
ctx.arc(r.x - offsetX, r.y - offsetY, r.radius, 0, Math.PI * 2);
ctx.fill();
ctx.globalAlpha = 1;
});

// Bots zeichnen
bots.forEach(bot => {
ctx.beginPath();
ctx.fillStyle = bot.color;
ctx.arc(bot.x - offsetX, bot.y - offsetY, bot.radius, 0, Math.PI * 2);
ctx.fill();

// Score
ctx.fillStyle = "white";
ctx.font = "bold 14px Arial";
ctx.textAlign = "center";
ctx.fillText(Math.floor(bot.score), bot.x - offsetX, bot.y - offsetY + 5);
});

// Player Pieces zeichnen
playerPieces.forEach(p => {
ctx.beginPath();
ctx.fillStyle = p.color;
ctx.arc(p.x - offsetX, p.y - offsetY, p.radius, 0, Math.PI * 2);
ctx.fill();

// Score
ctx.fillStyle = "white";
ctx.font = "bold 16px Arial";
ctx.textAlign = "center";
ctx.fillText(Math.floor(p.score), p.x - offsetX, p.y - offsetY + 6);
});
}

function gameLoop() {
update();
draw();
document.getElementById("info").innerText = "Score: " + Math.floor(player.score);
updateLeaderboard();
requestAnimationFrame(gameLoop);
}

// Split Button Event
document.getElementById("splitBtn").addEventListener("click", () => {
// Nur splitten, wenn genug Masse
if (player.score < 40) return;

const angle = Math.atan2(mouse.y - canvas.height / 2, mouse.x - canvas.width / 2);
const halfScore = player.score / 2;

// Neuer beweglicher Teil mit Boost
const newPart = {
x: player.x + Math.cos(angle) * (player.radius + 10),
y: player.y + Math.sin(angle) * (player.radius + 10),
radius: Math.sqrt(halfScore) + 10,
score: halfScore,
vx: Math.cos(angle) * 15,
vy: Math.sin(angle) * 15,
boostFrames: 240, // langer Boost
isMain: false,
color: player.color
};

// Toter Teil halbtransparent liegen lassen
botRemains.push({
x: player.x,
y: player.y,
radius: Math.sqrt(halfScore) + 10,
score: halfScore,
color: player.color
});

// Spieler verliert Hälfte
player.score = halfScore;
player.radius = Math.sqrt(halfScore) + 10;

playerPieces.push(newPart);
});

// Mouse tracking für Bewegung
canvas.addEventListener("mousemove", e => {
mouse.x = e.clientX;
mouse.y = e.clientY;
});

// Bots spawnen alle 3-5 Sekunden
setInterval(() => {
spawnBot();
}, 3000 + Math.random() * 2000);

function updateLeaderboard() {
const lb = document.getElementById("leaderboardList");

let allPlayers = playerPieces.concat(bots);
allPlayers = allPlayers.filter(p => p.score > 0);
allPlayers.sort((a,b) => b.score - a.score);

const top10 = allPlayers.slice(0, 10);

lb.innerHTML = "";
top10.forEach((p, i) => {
let name = p.isMain ? "Spieler" : (bots.includes(p) ? Bot #${bots.indexOf(p)+1} : "Teil");
if(!p.isMain && !bots.includes(p)){
name = "Teil";
}
const li = document.createElement("li");
li.textContent = ${i+1}. ${name}: ${Math.floor(p.score)};
li.style.color = p.color || "black";
lb.appendChild(li);
});
}

gameLoop();

window.addEventListener("resize", () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});

</script> </body> </html>
